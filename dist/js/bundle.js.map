{"version":3,"sources":["node_modules/browser-pack/_prelude.js","bundle.js","src/ts/ai.ts","src/ts/board.ts","src/ts/display.ts","src/ts/main.ts"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","module","Object","defineProperty","value","board_1","USER","COMP","getEmptySquares","board","indices","indexOf","forEach","v","push","minimax","player","depth","currentMoves","winner","getWinner","evaluateScore","score","opponent","bestScore","move","default","isSmart","squares","bestMove","getBoard","Math","floor","random","__spreadArray","this","to","from","pack","arguments","ar","l","Array","prototype","slice","concat","takeTurn","boardIsFull","getSquare","resetGame","resetBoard","setAiToHard","setMultiplayer","getPlayerNames","setPlayerNames","getScores","getCurrentPlayerMarker","ai_1","isMultiplayer","aiHardMode","players","X","name","marker","turn","O","gameBoard","_a","b","playSquare","state","successful","mark","setSquare","names","bool","displayElement","id","modal","document","getElementById","style","display","hideElement","writeBoardToPage","querySelectorAll","square","classList","add","resetBoardClasses","remove","writeInfoToPage","p1Label","querySelector","p1Info","p2Label","p2Info","p1Score","p2Score","_b","p1Name","p2Name","textContent","toString","parentElement","toggleNameInput","multi","p2NameInput","checked","win","button","addEventListener","easy","hard","index","Number","radio"],"mappings":"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","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",null,"/* eslint-disable no-param-reassign */\n// eslint-disable-next-line import/no-unresolved, import/extensions\nimport { Marker, getBoard, getWinner } from './board';\n\nconst MIN = -11;\nconst MAX = 11;\nconst USER: Marker = 'X';\nconst COMP: Marker = 'O';\nconst EMPTY = '';\n\n/**\n * Gets an array containing the indexes of unplayed squares on a board\n *\n * @param {string[]} board - An array representing game board state\n * @returns {number[]} An array containing indexes of empty spaces on the board\n */\nfunction getEmptySquares(board: string[]): number[] {\n  const indices: number[] = [];\n\n  if (board.indexOf(EMPTY) !== -1) {\n    board.forEach((v, i) => {\n      if (v === EMPTY) indices.push(i);\n    });\n  }\n\n  return indices;\n}\n\n/**\n * Returns a weighted score based on which player is returned from 'getWinner'.\n *\n * The score is weighted depending on how deep within a minimax loop, as moves\n * deeper into the loop will have less weight than a more recent win/loss.\n *\n * @param {string} winner - A string representing a winning player\n * @param {number} depth - # of moves away from the inital game state\n * @returns {string} The weighted score of the current win state\n */\nfunction evaluateScore(winner: string, depth: number): number {\n  if (winner === COMP) return 10 - depth;\n  if (winner === USER) return -10 + depth;\n  return 0;\n}\n\n/**\n * A function implementing the minimax algorithm. A recursive function that\n * loops through a tree of each possible branch of the game's state, and each\n * recursion is terminated once a game's win/loss/tie state is reached (i.e. it\n * reaches a leaf on that tree).\n *\n * Within each iteration of the loop, a score is passed through each layer;\n * and on the User's (represented by 'X') the most minimal score is found.\n * Likewise, on the computer's turn (represented by 'O') the most maximal score\n * is found. Bubbling up on each turn until the initial minmax() call is made.\n *\n * @param {string[]} board - A string representing a winning player\n * @param {Marker} player - An 'X' or 'O' to represent User or Computer.\n * @param {number} depth - # of moves away from the inital game state\n * @returns {number} The weighted minimal/maximal score of each branch.\n */\nfunction minimax(board: string[], player: Marker, depth: number): number {\n  const currentMoves = getEmptySquares(board);\n  const winner = getWinner(board);\n\n  // Check if the current board has a winner, or if a tie is reached.\n  if (winner !== EMPTY || currentMoves.length === 0) {\n    return evaluateScore(winner, depth);\n  }\n\n  const opponent: Marker = player === COMP ? USER : COMP;\n  let bestScore = player === COMP ? MIN : MAX;\n  let score: number;\n\n  // Iterate through each possible move available.\n  currentMoves.forEach((move) => {\n    // Perform move, do next minimax iteration, and then undo move\n    board[move] = player;\n    score = minimax(board, opponent, depth + 1);\n\n    // Set the best score if score is more maximal/minimal for computer/user\n    if (\n      (player === COMP && score > bestScore) ||\n      (player === USER && score < bestScore)\n    ) {\n      bestScore = score;\n    }\n\n    board[move] = EMPTY;\n  });\n\n  return bestScore;\n}\n\n/**\n * Gets the most optimal move to make, should be unbeatable. Uses minimax\n * algorithm to find the most optimal move, and then sets the best move to make\n * based on the branch that has the highest score.\n *\n * @returns {number} The most optimal move\n */\nfunction smartAiMove(): number {\n  const board = getBoard();\n  const currentMoves = getEmptySquares(board);\n  // Set bestMove to a valid move to satisfy compiler\n  let [bestMove] = currentMoves;\n  let bestScore = MIN;\n\n  currentMoves.forEach((move) => {\n    board[move] = COMP;\n    // Each minimax call needs depth to start at '1'. Starting at 0 results in\n    // non-optimal play due to scoring to be inaccurate.\n    const score = minimax(board, USER, 1);\n    board[move] = EMPTY;\n\n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = move;\n    }\n  });\n\n  return bestMove;\n}\n\n/**\n * Gets a random valid move to perform. Gets a list of all valid moves, and\n * returns a random one.\n *\n * @returns {number} A random move.\n */\nfunction randomAiMove(): number {\n  const board = getBoard();\n  const squares = getEmptySquares(board);\n\n  return squares[Math.floor(Math.random() * squares.length)];\n}\n\n/**\n * External call to get an AI move. The call declares whether the AI should be\n * \"smart\" or not, and then returns either an optimal move or a random move\n * based on that declaration.\n *\n * @param {boolean} isSmart - declares whether to use unbeatable or random AI\n * @returns {number} A valid move\n */\nexport default function aiMove(isSmart: boolean): number {\n  let move: number = 0;\n\n  if (isSmart) {\n    move = smartAiMove();\n  } else {\n    move = randomAiMove();\n  }\n\n  return move;\n}\n","// eslint-disable-next-line no-unused-vars, import/no-unresolved, import/extensions\nimport aiMove from './ai';\n\nexport type Marker = 'O' | 'X';\nexport type GameStatus = 'playing' | 'tie' | 'win';\n\ninterface Player {\n  name: string;\n  marker: Marker;\n  score: number;\n  turn: boolean;\n}\n\ninterface Players {\n  X: Player;\n  O: Player;\n}\n\nlet isMultiplayer = false;\nlet aiHardMode = false;\nlet board = ['', '', '', '', '', '', '', '', ''];\nconst players: Players = {\n  X: { name: '✖', marker: 'X', score: 0, turn: true },\n  O: { name: 'ⵔ', marker: 'O', score: 0, turn: false },\n};\n\n/**\n * Swaps which player's turn it is.\n */\nfunction swapPlayers(): void {\n  players.X.turn = !players.X.turn;\n  players.O.turn = !players.O.turn;\n}\n\n/**\n * Returns the who is currently playing\n *\n * @returns {Player} Object of the current turn's player.\n */\nfunction getCurrentPlayer(): Player {\n  if (players.X.turn) {\n    return players.X;\n  }\n  return players.O;\n}\n\n/**\n * Returns the Marker of who is currently playing\n *\n * @returns {Marker} 'X' or 'O' string representing the current turn's player.\n */\nexport function getCurrentPlayerMarker(): Marker {\n  const player = getCurrentPlayer();\n  return player.marker;\n}\n\n/**\n * Returns an array of the two player's scores.\n *\n * @returns {number[]} An array of player 'X' and player 'O's scores\n */\nexport function getScores(): number[] {\n  return [players.X.score, players.O.score];\n}\n\n/**\n * Sets the stored names of the two players\n *\n * @param {string[]} names - An array of two strings, 'X' and 'O' new names respectively\n */\nexport function setPlayerNames(names: string[]): void {\n  [players.X.name, players.O.name] = names;\n}\n\n/**\n * Returns the names of the two players\n *\n * @returns {string[]} An array of two strings, 'X' and 'O' names respectively\n */\nexport function getPlayerNames(): string[] {\n  return [players.X.name, players.O.name];\n}\n\n/**\n * Sets whether multiplayer is active.\n *\n * @param {boolean} bool - True for multiplayer, false for single player\n */\nexport function setMultiplayer(bool: boolean): void {\n  isMultiplayer = bool;\n}\n\n/**\n * Sets the AI difficulty\n *\n * @param {boolean} bool - True for hard AI, false for easy AI\n */\nexport function setAiToHard(bool: boolean): void {\n  aiHardMode = bool;\n}\n\n/**\n * Increments the current player's score\n *\n * @param {Player} player - the player to score to increment\n */\nfunction incrementScore(player: Marker): void {\n  players[player].score += 1;\n}\n\n/**\n * returns a shallow copy of the current board\n *\n * @returns {string[]} a copy of the game board\n */\nexport function getBoard(): string[] {\n  return [...board];\n}\n\n/**\n * Empties the current board and sets the current player back to 'X'\n */\nexport function resetBoard(): void {\n  board = ['', '', '', '', '', '', '', '', ''];\n  players.X.turn = true;\n  players.O.turn = false;\n}\n\n/**\n * Empties the current board and sets the current player back to 'X', and sets\n * both scores to 0\n */\nexport function resetGame(): void {\n  resetBoard();\n  players.X.score = 0;\n  players.O.score = 0;\n}\n\n/**\n * Gets the square at the given index\n *\n * @param {number} i - Index of the square you want.\n * @returns {string} The marker on the square. Either 'X', 'O', or ''.\n */\nexport function getSquare(i: number): string {\n  return board[i];\n}\n\n/**\n * Sets the value of the square at the given index; returns 'true' if\n * successful or 'false' if the square is invalid.\n *\n * @param {number} i - Index of the square you want.\n * @param {Marker} mark - The value to set at the square.\n * @returns {string} The marker on the square. Either 'X', 'O', or ''.\n */\nfunction setSquare(i: number, mark: Marker): boolean {\n  if (getSquare(i) === '') {\n    board[i] = mark;\n    return true;\n  }\n  return false;\n}\n\n/**\n * Checks each 'line' of the board to see if all three squares is filled by a\n * player. Returns the marker of the player if a winner is found; or '' if no\n * winner is found.\n *\n * @param {string[]} gameBoard - A 1D array representing the game board\n * @returns {string} Marker of the winner, or '' if no winner is found.\n */\nexport function getWinner(gameBoard: string[]): string {\n  let winner = '';\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ];\n\n  lines.forEach(([a, b, c]) => {\n    if (\n      gameBoard[a] !== '' &&\n      gameBoard[a] === gameBoard[b] &&\n      gameBoard[a] === gameBoard[c]\n    ) {\n      winner = gameBoard[a];\n    }\n  });\n\n  return winner;\n}\n\n/**\n * checks if the board has any empty spaces, and then returns true or false\n *\n * @returns {boolean} true if the board is full, false if not\n */\nexport function boardIsFull(): boolean {\n  return board.indexOf('') === -1;\n}\n\n/**\n * Plays a spot on the board from a given index, and if successful, then it\n * will return the status of the game.\n *\n * @param {number} i - Index of the square to play on.\n * @returns {GameStatus} Status of the game; 'playing', 'win', or 'tie'.\n */\nfunction playSquare(i: number): GameStatus {\n  let state: GameStatus = 'playing';\n\n  const marker = getCurrentPlayerMarker();\n  const successful = setSquare(i, marker);\n\n  if (successful) {\n    const winner = getWinner(board);\n    if (winner !== '') {\n      state = 'win';\n      incrementScore(winner as Marker);\n      return state;\n    }\n    if (boardIsFull()) {\n      state = 'tie';\n      return state;\n    }\n  }\n\n  swapPlayers();\n  return state;\n}\n\n/**\n * Plays a spot on the board from a given index, and if single player then it\n * will perform an AI's move as well.\n *\n * @param {number} i - Index of the square to play on.\n * @returns {GameStatus} Status of the game; 'playing', 'win', or 'tie'.\n */\nexport function takeTurn(i: number): GameStatus {\n  let state: GameStatus = 'playing';\n\n  if (isMultiplayer) {\n    state = playSquare(i);\n    return state;\n  }\n\n  state = playSquare(i);\n  if (state === 'win' || state === 'tie') return state;\n\n  const aiSquare = aiMove(aiHardMode);\n  state = playSquare(aiSquare);\n  return state;\n}\n","// eslint-disable-next-line import/no-unresolved, import/extensions\nimport { GameStatus } from './board';\nimport * as board from './board';\n\n/**\n * Displays an element with the declared ID\n *\n * @param {type} id - ID selector of the element you want to show\n */\nfunction displayElement(id: string): void {\n  const modal = document.getElementById(id);\n  if (modal != null) {\n    modal.style.display = 'block';\n  }\n}\n\n/**\n * Hides an element with the declared ID\n *\n * @param {type} id - ID selector of the element you want to hide\n */\nfunction hideElement(id: string): void {\n  const modal = document.getElementById(id);\n  if (modal != null) {\n    modal.style.display = 'none';\n  }\n}\n\n/**\n * Write board to page, gets the associated squares of the board from board.ts\n * and then adds a class to the square on the page that's associated with the\n * maker; using the CSS class to display it on the page.\n */\nfunction writeBoardToPage(): void {\n  const squares = document.querySelectorAll<HTMLElement>('.square');\n  let marker: string = '';\n\n  squares.forEach((square, i) => {\n    marker = board.getSquare(i);\n    if (marker !== '') {\n      square.classList.add(`${marker}`);\n    }\n  });\n}\n\n/**\n * Iterates through all of the squares on the page, and removes any player\n * marker classes from them.\n */\nfunction resetBoardClasses(): void {\n  const squares = document.querySelectorAll<HTMLElement>('.square');\n\n  squares.forEach((square) => {\n    square.classList.remove('X', 'O');\n  });\n}\n\n/**\n * Gets the 'X' and 'O' player's label, scores, and current player's marker and\n * writes the information on the UI at the top of the page.\n */\nfunction writeInfoToPage(): void {\n  const p1Label = document.querySelector('.p1-label');\n  const p1Info = document.querySelector('.p1-info');\n  const turn = document.querySelectorAll('.turn-info');\n  const p2Label = document.querySelector('.p2-label');\n  const p2Info = document.querySelector('.p2-info');\n\n  const [p1Score, p2Score] = board.getScores();\n  const [p1Name, p2Name] = board.getPlayerNames();\n  const player = board.getCurrentPlayerMarker();\n  const marker = player === 'X' ? '✖' : '○';\n\n  p1Label!.textContent = `${p1Name}\\nScore`;\n  p1Info!.textContent = p1Score.toString();\n  turn[0].parentElement!.classList.value = `${player} infobox`;\n  turn.forEach((e) => {\n    e.textContent = marker;\n  });\n  p2Label!.textContent = `${p2Name}\\nScore`;\n  p2Info!.textContent = p2Score.toString();\n}\n\n/**\n * Adds event handlers to the squares on the page. On each click, the index of\n * the square is grabbed, and the square is played on the board. Writing the\n * new board to the screen as well as turn info. Finally checking if a win or\n * tie modal needs to be displayed.\n */\nfunction setSquareEventHandlers(): void {\n  const squares = document.querySelectorAll<HTMLElement>('.square');\n  let win: GameStatus;\n\n  squares.forEach((square) => {\n    square.addEventListener('click', () => {\n      const index: number = Number(square.id);\n      win = board.takeTurn(index);\n      writeInfoToPage();\n      writeBoardToPage();\n\n      if (win === 'win') displayElement('win-screen');\n      if (win === 'tie') displayElement('tie-screen');\n    });\n  });\n}\n\n/**\n * Sets an event listener for the 'new game' button on win and ties screens.\n * When the button is clicked, the board is reset and new player stats are\n * written to the screen. Finally hiding the win/tie modal\n */\nfunction setNewGameButton(): void {\n  const newGame = document.querySelectorAll('.new-game');\n\n  newGame!.forEach((button) => {\n    button.addEventListener('click', () => {\n      board.resetBoard();\n      resetBoardClasses();\n      writeBoardToPage();\n      writeInfoToPage();\n      hideElement('win-screen');\n      hideElement('tie-screen');\n    });\n  });\n}\n\n/**\n * Adds an event listener on the 'Start Game' button on the name screen. First\n * it gets the player names entered and the info about the number of players\n * and difficulty of AI.\n *\n * Then it sets that info onto the board module; before hiding the name modal.\n */\nfunction setNameSubmitButton(): void {\n  const submit = document.querySelector('.name-submit');\n\n  submit!.addEventListener('click', () => {\n    const p1Name = (<HTMLInputElement>document.getElementById('p1-name')).value;\n    const p2Name = (<HTMLInputElement>document.getElementById('p2-name')).value;\n    const multi = document.getElementById('multi-player') as HTMLInputElement;\n    const easy = document.getElementById('easy-mode') as HTMLInputElement;\n    const hard = document.getElementById('hard-mode') as HTMLInputElement;\n\n    if (multi!.checked) {\n      board.setMultiplayer(true);\n    } else {\n      board.setMultiplayer(false);\n      if (easy!.checked) board.setAiToHard(false);\n      if (hard!.checked) board.setAiToHard(true);\n    }\n    board.setPlayerNames([p1Name, p2Name]);\n    writeInfoToPage();\n    hideElement('names-screen');\n  });\n}\n\n/**\n * Sets an event listener onto the reset button. It resets the state of the\n * game, as well as the classes and info on the page. Before displaying the\n * name modal again.\n */\nfunction setResetButton(): void {\n  const newGame = document.querySelector('.reset');\n\n  newGame!.addEventListener('click', () => {\n    board.resetGame();\n    resetBoardClasses();\n    writeBoardToPage();\n    writeInfoToPage();\n    displayElement('names-screen');\n  });\n}\n\n/**\n * Sets a toggle on the 'O' (or Player 2) name input. If a single-player game\n * is selected, the name is hidden. If a two-player game is selected, then the\n * element is shown.\n */\nfunction toggleNameInput(): void {\n  const multi = document.getElementById('multi-player') as HTMLInputElement;\n  const p2NameInput = document.getElementById('p2-input');\n\n  if (multi!.checked) {\n    p2NameInput!.style.display = 'block';\n  } else {\n    p2NameInput!.style.display = 'none';\n  }\n}\n\n/**\n * Sets a name toggle on the player screen's radio buttons.\n */\nfunction setPlayerSelectHandler(): void {\n  const radioButtons = document.querySelectorAll('input[name=\"player-select\"]');\n  radioButtons.forEach((radio) => {\n    radio.addEventListener('click', toggleNameInput);\n  });\n}\n\n/**\n * Sets the event handlers on the page, and then displays the board and info.\n */\nexport default function displayHandler(): void {\n  setNewGameButton();\n  setNameSubmitButton();\n  setResetButton();\n  setSquareEventHandlers();\n  setPlayerSelectHandler();\n  writeBoardToPage();\n  writeInfoToPage();\n}\n","// eslint-disable-next-line import/extensions\nimport displayHandler from './display';\n\ndisplayHandler();\n"]}